import{_ as t,o as e,c as d,f as a}from"./app-48ed2f42.js";const n={},r=a(`<blockquote><p>面试题：composition api相比于option api有哪些优势？</p></blockquote><p>不同于reactivity api，composition api提供的函数很多是与组件深度绑定的，不能脱离组件而存在。</p><h1 id="setup" tabindex="-1"><a class="header-anchor" href="#setup" aria-hidden="true">#</a> setup</h1><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// component</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 该函数在组件属性被赋值后立即执行，早于所有生命周期钩子函数</span>
    <span class="token comment">// props 是一个对象，包含了所有的组件属性值</span>
    <span class="token comment">// context 是一个对象，提供了组件所需的上下文信息</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>context对象的成员</p><table><thead><tr><th>成员</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>attrs</td><td>对象</td><td>同<code>vue2</code>的<code>this.$attrs</code></td></tr><tr><td>slots</td><td>对象</td><td>同<code>vue2</code>的<code>this.$slots</code></td></tr><tr><td>emit</td><td>方法</td><td>同<code>vue2</code>的<code>this.$emit</code></td></tr></tbody></table><h1 id="生命周期函数" tabindex="-1"><a class="header-anchor" href="#生命周期函数" aria-hidden="true">#</a> 生命周期函数</h1><table><thead><tr><th>vue2 option api</th><th>vue3 option api</th><th>vue 3 composition api</th></tr></thead><tbody><tr><td>beforeCreate</td><td>beforeCreate</td><td>不再需要，代码可直接置于setup中</td></tr><tr><td>created</td><td>created</td><td>不再需要，代码可直接置于setup中</td></tr><tr><td>beforeMount</td><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td><mark>改</mark> beforeUnmount</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td><mark>改</mark>unmounted</td><td>onUnmounted</td></tr><tr><td>errorCaptured</td><td>errorCaptured</td><td>onErrorCaptured</td></tr><tr><td>-</td><td><mark>新</mark>renderTracked</td><td>onRenderTracked</td></tr><tr><td>-</td><td><mark>新</mark>renderTriggered</td><td>onRenderTriggered</td></tr></tbody></table><p>新增钩子函数说明：</p><table><thead><tr><th>钩子函数</th><th>参数</th><th>执行时机</th></tr></thead><tbody><tr><td>renderTracked</td><td>DebuggerEvent</td><td>渲染vdom收集到的每一次依赖时</td></tr><tr><td>renderTriggered</td><td>DebuggerEvent</td><td>某个依赖变化导致组件重新渲染时</td></tr></tbody></table><p>DebuggerEvent:</p><ul><li>target: 跟踪或触发渲染的对象</li><li>key: 跟踪或触发渲染的属性</li><li>type: 跟踪或触发渲染的方式</li></ul><h1 id="面试题参考答案" tabindex="-1"><a class="header-anchor" href="#面试题参考答案" aria-hidden="true">#</a> 面试题参考答案</h1><p>面试题：composition api相比于option api有哪些优势？</p><blockquote><p>从两个方面回答：</p><ol><li>为了更好的逻辑复用和代码组织</li><li>更好的类型推导</li></ol></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>有了composition api，配合reactivity api，可以在组件内部进行更加细粒度的控制，使得组件中不同的功能高度聚合，提升了代码的可维护性。对于不同组件的相同功能，也能够更好的复用。
相比于option api，composition api中没有了指向奇怪的this，所有的api变得更加函数式，这有利于和类型推断系统比如TS深度配合。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,16),o=[r];function s(i,p){return e(),d("div",null,o)}const l=t(n,[["render",s],["__file","3.html.vue"]]);export{l as default};
